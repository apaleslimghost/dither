<!doctype html>
<meta charset="utf8">

<img id="img" src="./IMG_1575.jpeg" width="480" height="640">

<canvas width="480" height="640" id="canvas"></canvas>
<canvas width="480" height="640" id="canvas2"></canvas>

<style>
	body {
		margin: 0;
	}

	canvas {
		image-rendering: pixelated;
	}
</style>

<script type="module">
	const /** @type {HTMLCanvasElement} */ canvas = document.getElementById('canvas')
	const /** @type {HTMLImageElement} */ img = document.getElementById('img')

	const ctx = canvas.getContext('2d')

	const srgbLinear = (/** @type {number} */ c) => (
		c <= 0.04045
			? c / 12.92
			: ((c + 0.055) / 1.055) ** 2.4
	)

	const luminance = (
		/** @type {number} */ r,
		/** @type {number} */ g,
		/** @type {number} */ b,
	) => 0.2126 * srgbLinear(r / 255) + 0.7152 * srgbLinear(g / 255) + 0.0722 * srgbLinear(b / 255)

	const saturation = (
		/** @type {number} */ r,
		/** @type {number} */ g,
		/** @type {number} */ b,
	) => {
		const rNorm = r / 255;
		const gNorm = g / 255;
		const bNorm = b / 255;

		const max = Math.max(rNorm, gNorm, bNorm);
		const min = Math.min(rNorm, gNorm, bNorm);
		const d = max - min;

		const lightness = (max + min) / 2;

		if (max === min) {
			return 0;
		} else {
			return lightness > 0.5 ? d / (2 - max - min) : d / (max + min);
		}

		return saturation;
	}

	const bayer8 = [
		 0, 32,  8, 40,  2, 34, 10, 42,
		48, 16, 56, 24, 50, 18, 58, 26,
		12, 44,  4, 36, 14, 46,  6, 38,
		60, 28, 52, 20, 62, 30, 54, 22,
		 3, 35, 11, 43,  1, 33,  9, 41,
		51, 19, 59, 27, 49, 17, 57, 25,
		15, 47,  7, 39, 13, 45,  5, 37,
		63, 31, 55, 23, 61, 29, 53, 21,
	].map(b => b / 64 - 0.5)

	if(img.complete) {
		drawImage()
	} else {
		img.addEventListener('load', drawImage, {once: true})
	}

	function pickPaletteColor(
		/** @type {Uint8ClampedArray} */ data,
		/** @type {Uint32Array} */ indices
	) {
		const index = indices[indices.length - 1]
		return data.slice(index, index + 4)
	}

	function nearestColor(
		/** @type{[number, number, number, number][]} */ palette,
		/** @type{[number, number, number, number]} */ [r,g,b,a]
	) {
		const distances = palette.map(
			([pr, pg, pb, pa]) => Math.sqrt(
				(r - pr) ** 2 +
				(g - pg) ** 2 +
				(b - pb) ** 2 +
				(a - pa) ** 2
			)
		)

		const closest = Math.min(...distances)
		const index = distances.findIndex(d => d === closest)
		return palette[index]
	}

	function propagateErrorToPixel(
		/** @type{ImageData} */ imageData,
		/** @type{number} */ x,
		/** @type{number} */ y,
		/** @type{number} */ dx,
		/** @type{number} */ dy,
		/** @type{number} */ error,
		/** @type{0 | 1 | 2 | 3} */ channel
	) {
		const nx = x + dx
		const ny = y + dy
		const nIndex = (ny * imageData.width + nx) * 4

		if(
			nx >= 0 &&
			nx < imageData.width &&
			ny >= 0 &&
			ny < imageData.height
		) {
			imageData.data[nIndex + channel] = Math.max(
				0,
				Math.min(255, imageData.data[nIndex + channel] + error)
			)
		}
	}

	function propagateError(
		/** @type{ImageData} */ imageData,
		/** @type{number} */ index,
		/** @type{number} */ error,
		/** @type{0 | 1 | 2 | 3} */ channel
	) {
		const x = (index / 4) % imageData.width
		const y = Math.floor((index / 4) / imageData.width)

		///// Atkinson
		propagateErrorToPixel(imageData, x, y,  1, 0, error / 8, channel)
		propagateErrorToPixel(imageData, x, y,  2, 0, error / 8, channel)
		propagateErrorToPixel(imageData, x, y, -1, 1, error / 8, channel)
		propagateErrorToPixel(imageData, x, y,  0, 1, error / 8, channel)
		propagateErrorToPixel(imageData, x, y,  1, 1, error / 8, channel)
		propagateErrorToPixel(imageData, x, y,  0, 2, error / 8, channel)


		///// Floyd-Steinberg
		// propagateErrorToPixel(imageData, x, y,   1, 0, 7 * error / 16, channel)
		// propagateErrorToPixel(imageData, x, y,  -1, 1, 3 * error / 16, channel)
		// propagateErrorToPixel(imageData, x, y,   0, 1, 5 * error / 16, channel)
		// propagateErrorToPixel(imageData, x, y,   1, 1, 1 * error / 16, channel)
	}

	function drawImage() {
		ctx.drawImage(img, 0, 0)
		const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
		const paletteSize = 16
		const spread = 255 / Math.log2(paletteSize)

		const buckets = medianCut(imageData.data, paletteSize)
		buckets.sort((a, b) => luminance(a) - luminance(b))
		const palette = buckets.map(bucket => pickPaletteColor(imageData.data, bucket))

		for(let index = 0; index < imageData.data.length; index += 4) {
			const x = (index / 4) % imageData.width
			const y = Math.floor((index / 4) / imageData.width)
			const bayerFactor = bayer8[(x % 8) + 8 * (y % 8)]

			const [r, g, b] = nearestColor(palette, imageData.data.slice(index, index + 4).map(c => c + spread * bayerFactor)).map(Math.round)

			const rError = imageData.data[index] - r
			const gError = imageData.data[index + 1] - g
			const bError = imageData.data[index + 2] - b

			imageData.data[index] = r
			imageData.data[index + 1] = g
			imageData.data[index + 2] = b
			imageData.data[index + 3] = 255

			propagateError(imageData, index, rError, 0)
			propagateError(imageData, index, gError, 1)
			propagateError(imageData, index, bError, 2)
		}

		ctx.putImageData(imageData, 0, 0)
	}

	function greatestSpan(
		/** @type {Uint8ClampedArray} */ data,
		/** @type {Uint32Array} */ indices,
	) {
		let rMin, rMax, gMin, gMax, bMin, bMax

		for(let i = 0; i < indices.length; i += 1) {
			const r = data[indices[i]]
			const g = data[indices[i] + 1]
			const b = data[indices[i] + 2]

			rMin = Math.min(r, rMin ?? Infinity)
			rMax = Math.max(r, rMax ?? -Infinity)
			gMin = Math.min(g, gMin ?? Infinity)
			gMax = Math.max(g, gMax ?? -Infinity)
			bMin = Math.min(b, bMin ?? Infinity)
			bMax = Math.max(b, bMax ?? -Infinity)
		}

		const rSpan = rMax - rMin
		const gSpan = gMax - gMin
		const bSpan = bMax - bMin

		const maxSpan = Math.max(rSpan, gSpan, bSpan)

		const channel = maxSpan === rSpan ? 0
		              : maxSpan === gSpan ? 1
		              : maxSpan === bSpan ? 2
		              : NaN

		return {channel, maxSpan}
	}


	function sortImageData(
		/** @type {Uint8ClampedArray} */ data,
		/** @type {Uint32Array} */ indices,
		/** @type number */ channel
	) {
		indices.sort(
			(a, b) => data[a + channel] - data[b + channel]
		)
	}

	function bucketWithGreatestSpan(
		/** @type {Uint8ClampedArray} */ data,
		/** @type {Array<Uint32Array>} */ buckets
	) {
		const spans = buckets.map(bucket => greatestSpan(data, bucket))
		const max = Math.max(...spans.map(span => span.maxSpan))
		const index = spans.findIndex(span => max === span.maxSpan)
		return {
			index,
			bucket: buckets[index],
			...spans[index]
		}
	}

	function medianCut(
		/** @type {Uint8ClampedArray} */ data,
		/** @type {number} */ paletteSize,
		/** @type {Uint32Array} */ indices = Uint32Array.from({length: data.length / 4}, (_, i) => i * 4)
	) {
		if(paletteSize === 1) {
			return [indices]
		}

		const {channel} = greatestSpan(data, indices)
		sortImageData(data, indices, channel)

		const lower = indices.slice(0, 4 * indices.length / 8)
		const upper = indices.slice(4 * indices.length / 8, indices.length)

		return medianCut(data, paletteSize / 2, lower).concat(medianCut(data, paletteSize / 2, upper))
	}

</script>
